Vagrant – консольная утилита, которая управляет виртуальными машинами.
По умолчанию Vagrant работает с системой виртуализации VirtualBox.

Vagrant создает изолированные среды разработки,
при этом не жертвуя привычными инструментами (редакторы, браузеры и т. д.) и оставляя основную систему чистой.

В папке проекта создается файл Vagrantfile с описанием конфигурации виртуальной машины, в котором указывается операционная система,
выделяемые ресурсы, сетевые настройки и скрипты по установке и настройке дополнительных программ.

//Проверка версии
vagrant -v

//Создание Vagrantfile в текущей директории. В нем на языке Ruby описывается конфигурация виртуальной машины
vagrant init

//Запускает виртуальную машину, создавая её, если она ещё не существует. Также выполняет все настройки, указанные в Vagrantfile, включая синхронизацию папок, настройку сети, установку зависимостей и т.д.
vagrant up
vagrant up --debug - Запуск с подробным отображением ошибок

//Останавливает запущенную виртуальную машину. Это аналог нажатия кнопки "Выключить" в VirtualBox. Виртуальная машина остаётся сохранённой на диске и может быть запущена снова.
vagrant halt

//Перезапускает виртуальную машину. Полезно, если вы внесли изменения в Vagrantfile (например, изменили настройки сети или синхронизации) и хотите их применить.
vagrant reload

//Полностью удаляет виртуальную машину вместе со всеми её файлами. После выполнения этой команды машина исчезает из VirtualBox.
vagrant destroy

//Сохраняет текущее состояние виртуальной машины и останавливает её. Это аналог функции "Сохранить состояние" в VirtualBox. Позволяет быстро вернуться к работе без полной перезагрузки.
vagrant suspend

//Возобновляет работу виртуальной машины после выполнения команды vagrant suspend.
vagrant resume

//Подключается к виртуальной машине через SSH. Это позволяет вам работать с машиной из командной строки.
vagrant ssh

//Показывает статус виртуальной машины (например, запущена ли она, остановлена или отсутствует).
vagrant status

//Показывает список всех базовых образов (boxes), которые доступны на вашем компьютере.
vagrant box list

//Cкачать бокс на компьютер
vagrant box add ubuntu/jammy64

//Удаляет базовый образ из локального хранилища.
vagrant box remove <box-name>

//Показывает список всех машин Vagrant, созданных на вашем компьютере (даже если вы находитесь в другой директории).
vagrant global-status

//Команда vagrant provision выполняет провиженинг (настройку) виртуальной машины.
Это процесс выполнения скриптов или инструкций, которые указаны в Vagrantfile для настройки машины после ее создания.
vagrant provision

--пример:
config.vm.provision "shell", inline: <<-SHELL
    sudo apt update
    sudo apt install -y python3-pip python3-virtualenv postgresql nginx
  SHELL


---- Запуск на Linux Сервере без Docker ----
Будем использовать:
gunicorn
nginx

//Переходим в нужный нам каталог
cd opt/myapp

//Обновляем сведения о пакетах
sudo apt update

//Устанавливаем pip venv postgres nginx - они нужны для проекта
-y или --assume-yes   чтобы не запрашивался ввод Y/n
--quiet или -q   уменьшает вывод в терминале.
sudo apt install -y python3-pip python3-virtualenv postgresql nginx

Создаём виртуальное окружение. --always-copy так как используется синхронизация папок
virtualenv venv --always-copy

//активация окружения
. ./venv/bin/activate

//Устанавиваем зависимости
pip install -r requirements.txt

//Войдём в консоль postgres
sudo -u postgres psql

//Проверка версии
select version();

//Создадим базу
create database django_app;
create user django_app with password 'django_app';
grant all privileges on database django_app to django_app;

//Так как postgres 15 версии:
alter database django_app owner to django_app;
\q

Начальная настройка postgres закончена

python3 ./django_project/manage.py migrate
python3 ./django_project/manage.py createsuperuser
admin
admin@example.com
admin
admin


База создана схема применена суперпользователь создан


---- Настройка gunicorn ----
gunicorn используется для взаимодействия между Django и веб-сервером
Обёртка, которая будет запускать Django приложение в несколиких экземплярах

pip install gunicorn

-- Настройки чтобы через gunicorn запустить приложение
Понаобится несколько конфигурационных файлов:
Добавляем папку conf
Назовём файл по имени приложения, которое будет стартовать
gunicorn.socket - специальный файл, который описывает UNIX сокет
сокет будет подниматься системной службой systemD, которая ответственна за запуск и остановку и выполнение сервисов


Описание:
[Unit]
Description=gunicorn socket

Сам сокет - где будет этот сокет располагаться на файловой системе linux
[Socket]
ListenStream=/run/gunicorn.sock

Стандартная служебная зависимост что он будет запускаться сокетом
[Install]
WantedBy=sockets.target

---- Теперь нужно подготовить ещё один файл для работы с gunicorn ----
- конфигурация  которая будет запускать сам gunicorn чтобы он через этот сокет отдавал данные через приложение
Создаём файл gunicorn.service

файл systemd unit для конфигурации сервиса Gunicorn, который запускает WSGI-приложение:
[Unit]
Description=gunicorn daemon: Это описание сервиса, чтобы другие могли понять, что делает данный юнит — он является демоном Gunicorn.
Requires=gunicorn.socket: Означает, что этот сервис зависит от юнита gunicorn.socket. Он не будет запущен, если юнит gunicorn.socket не будет активирован.
After=network.target: Указывает, что юнит должен запускаться только после того, как сеть была настроена (после достижения network.target).

Не используем пользователя root чтобы не допустить проблем с безопасностью

[Service]
User=www-data: Указывает, что сервис будет запущен от имени пользователя www-data.
Group=www-data: Указывает, что сервис будет запущен в группе www-data.
WorkingDirectory=/opt/myapp/app: Указывает рабочую директорию, в которой будет запущен сервис.
ExecStart=...: Команда, которую systemd выполняет для запуска сервиса. Здесь запускается gunicorn из виртуального окружения, с параметрами:

--access-logfile -: Логирование доступа в стандартный вывод.
--workers 3: Количество воркеров, обслуживающих запросы (в данном случае 3 воркера).
--bind unix:/run/gunicorn.sock: Привязка Gunicorn к UNIX-сокету, расположенному по пути /run/gunicorn.sock.
app.wsgi:application: Указывает путь к WSGI-приложению, которому Gunicorn должен передавать HTTP-запросы.

[Install]
WantedBy=multi-user.target: Указывает, что данный юнит должен запускаться в многопользовательской среде (уровень инициализации с более чем одной пользовательской сессией), обычно это почти вся загрузка системы.
Этот файл, скорее всего, будет находиться в директории /etc/systemd/system/ и позволяет управлять сервисом Gunicorn с помощью systemctl, например, запускать и останавливать его.


Файл с описанием сервиса подготовлен. Нужно сделать так, чтобы они были использованы системой
Можно их скопироватьв  каталог etc где они обычно распологаются
Но мы сделаем симулинк чтобы конфигурационные файлы оставались в рамках каталога с проектом
Если что-то поменяем, сможем применить без дополнительного копирования

Делаем симулинки:
sudo ln -s /opt/myapp/conf/gunicorn.socket /etc/systemd/system/

sudo ln -s /opt/myapp/conf/gunicorn.service /etc/systemd/system/

Чтобы systemd понял что мы ему добавили описаное новой конфигурации сокета и сервиса, необходимо выоплнить команду:
Эта команда сообщает systemd сервису что нужно перезагрузить файлы сервиса которые находятся на диске
//Пока мы этого не сделаем, он пользоваться этими файлами не будет
sudo systemctl daemon-reload


//Запустим наш сокет
sudo systemctl start gunicorn.socket

//И сразу же его включим
//Пока мы его не включим, в случае перезагрузки сервера он не будет заново включен
sudo systemctl enable gunicorn.socket
Результат - Created symlink /etc/systemd/system/sockets.target.wants/gunicorn.socket → /opt/myapp/conf/gunicorn.socket.

//Теперь мы можем проверить статус gunicorn.socket
sudo systemctl status gunicorn.socket

//Можно проверить создался ои файл в файловой системе
file /run/gunicorn.sock

Теперь нужно убедиться что Django приложение через сокет будет доступно
Юникорн сервис должен автоматически запуститься в тот момент, когда мы будем обращаться к юникорн сокету
//Подключимся сразу же к юникс сокету который подняли
curl --unix-socket /run/gunicorn.sock localhost

Recv failure: Connection reset by peer

Изменяем настройки
ALLOWED_HOSTS = ['localhost', 'myapp.django']



---- Настройка Nginx ----













---- Запуск на Linux Серере через docker-compose ----







